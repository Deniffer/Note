---
title: the model of memory
tag: csapp
abbrlink: 255d2894
date: 2020-07-08 15:12:20
---

### 半导体存储器
- 半导体存储器的组成：存储矩阵，译码驱动，读写电路，读写控制线，片选线，地址线和控制线 

- RAM 随机存取存储器（触发式原理），主要被用于制作主存，cache 
	- SRAM(static Random Access Memory) 静态随机存取存储器： SRAM不需要刷新电路也可以保存内部存储的数据，而DRAM需要每隔一段时间就刷新充电一次，否则内部的数据就会消失，因此SRAM具有较高的性能。
		- SRAM的构成：存储单元阵列，地址译码器，灵敏放大器，控制电路，缓冲/驱动电路
		- 优点：SRAM用双稳态触发器（六晶体管MOS来记忆消息的），SRAM速度非常快，通常能以20ns的速度工作
		- 缺点：集成度低，每个SRAM单元都需要4-6个晶体管和其他部件构成，SRAM芯片体积更大

	- DRAM(Dynamic Random Access Memory) 动态随机存取存储器（电容充电原理）：由于现实中晶体管存在漏电现象，导致电容上所存储的电荷数量不足以正确的判别数据，所以需要周期性的充电刷新。
		- 工作原理： 利用电容内所存储电荷的多寡来代表一个二进制位。DRAM通常以1个晶体管和1个电容	为单位排成二维矩阵，其中基本操作机制分为read和write，读的时候让BitLine先充电到操作电压的一半，然后把晶体管打开让BL和电容产生电荷共享现象，如内部存储值为1，则BL的电压会被电荷共享抬高到高于操作电压的一半，得到BL的电压后，经过放大器来判别内部值是0还是1。
		- 优点：只需1个晶体管，1个电容就可以形成一个存储单元. 地址线复用，行列分两次送
		- 缺点： DRAM上的电荷只能维持1-2ms，因此即使电源不断电，信息也会自动消失，为此需要每隔一个固定的时间进行刷新，通常取2ms，称为刷新周期，有3种刷新方式：集中刷新，分散刷新， 异步刷新。

- ROM(Read Only Memory)
根据制造工艺的不同，ROM可以分为MROM，PROM，EPROM,Flash Memory,Solid State Drives这几种。
	- MROM(掩模式只读存储器)：可靠性高，价格便宜，灵活性差
	- PROM(一次可编程只读存储器) Programmable ROM 可以实现一次编程，一旦写入无法更改。
	- EPROM（可擦除可编程只读存储器）Erasable Programmable ROM 可分为紫外线擦除（UVEPROM）和电擦除（EEPROM）electric， 不能当作主存的原因是编程次数有限，且写入太慢。
	- Flash Memory 闪存： 牛逼 [闪存介绍](https://baike.baidu.com/item/%E9%97%AA%E5%AD%98)
	- SSD (Solid State Drives) 固态硬盘：基于闪存的固态硬盘是用固态电子存储芯片阵列制成的硬盘，有控制单元和存储单元。

---------------------------
### 主存储器和CPU的连接

- RAM芯片总结
	- 地址线Ai ：引脚数和存储芯片的单元数有关
	- 数据线Di ：引脚数和存储芯片的字长有关
	- 片选信号 CS ：只有cs有效，芯片才被选中，所连地址线才有效，才可以进行读写。
	- 读/写信号控制线 WE（低电平） : 为0，控制写入电路写入；为1控制读出电路读出。
	- 电源线，地址线

- 位、字扩展法
	- 位扩展法： CPU的数据线数和存储芯片的数据位数不同，此时必须对存储芯片进行位扩展，用多个存储器件对字长进行扩充，增加存储字长，使其数据位数与CPU的数据线数相等。
	- 字扩展法： 增加存储器中字的存储数量。

- 存储芯片的地址分配和片选
	- 线选法 ：造成地址空间浪费，不连续， 优点不需要地址译码器，简单。
	- 译码片选法 ： 用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号，解决地址空间不连续问题。














### 三种刷新方式
假设刷新1行的时间为0.5μs（刷新时间是等于存取周期的。因为刷新的过程与一次存取相同，只是没有在总线上输入输出。顺便说一下存取周期＞真正用于存取的时间，因为存取周期内、存取操作结束后仍然需要一些时间来更改状态。——对于SRAM也是这样，对于DRAM更是如此）。
[三种刷新方式详解](https://blog.csdn.net/piscesq329a/article/details/9244723)
1. 集中刷新：指在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为“死时间”，又称访存“死区”。
快到2ms的时候，停止一切对内存的读取操作，使用0.5μs×64对64行依次刷新。这将占用3.2μs。在这3.2μs中，内存只用来刷新，阻塞一切存取操作。
补充一点给楼主：为什么刷新与存取不能并行？：因为内存就一套地址译码和片选装置，刷新与存取有相似的过程，它要选中一行——这期间片选线、地址线、地址译码器全被占用着。同理，刷新操作之间也不能并行——意味着一次只能刷一行。

2. 分散刷新： 把对每行的刷新分散到各个工作周期中，也即在每个存取操作过后绑定一个刷新操作，存取周期就成了0.5us+0.5us=1us<<2ms

3.   异步刷新：分散刷新的刷新周期64μs ，其实根本不需要这么频繁，有些浪费，异步刷新就是恰好卡在2ms这个时间点上。对于每行以2ms为刷新周期足够了，刷新循环到它需要64刷新次操作， 2ms ÷ 64 作为【每次刷新的周期】，（注意每次刷新周期与特定行的刷新周期的不同：每次刷新间隔指对于内存来说它隔多长时间就进行一次刷新操作，轮着刷新时，刷新的行是上一次刷新的行的下一行——是不同的两行，但对于全局内存来说确实是两次刷新操作间隔。特定哪一行的刷新周期：下一次对它进行刷新的间隔，期间要经过64次内存刷新周期才又轮得到它。）过64次刚好保证每行的刷新周期为2ms。刷新操作周期为2ms ÷ 64 。但是这个时间并不是绑定在存取周期内，所以仍然是拒绝存取的死时间。但是它已经很小了。所以这种刷新策略非常可行。

### 主存储器与CPU的连接