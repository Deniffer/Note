---
title: 整数运算与浮点数
tags: csapp
abbrlink: b0e81ec
date: 2020-07-02 20:35:54
---

### 整数运算之加法(Addition)
对于bit level的整数运算和我们常见的十进制运算是不一样的，这带来了难以理解的地方，所以今天打算来讲讲在bit level的整数运算（二进制）
> 考虑一个非负整数 0<= x,y <= 2^w,其中x，y都能表示为w位的无符号数字，一般地我们认为x+y处在的范围在0<=x+y<=2^(w+1)-2(其中减2是因为x，y的最大值均为2^w-1) 也即需要w+1位来表示x+y的结果，但是由于如果保持这样的“字长膨胀”的话(字长膨胀指的是x+y的结果再加上另外一个值 就可能需要2^w+2来表示)，就会带来麻烦。

所以更常见的来说，编程语言支持固定精度的运算(这也是导致一些奇奇怪怪的运算结果发生的原因，比如两正数相加得到负数) 也就是说我们只需要保持w位不变，就能表示w+1位的结果(这其中的原因是因为编译器在其中做了处理)

- 无符号加法(unsigned addition)
对于任意0 <= x,y <= 2^w的x，y 有：

 x+\_{w}^{u} y=\left\ {\begin{array}{ll}
x+y, & x+y<2^{w} \\x+y-2^{w}, & 2^{w} \leqslant x+y<2^{w+1}
\end{array}\right. 

也即对于无符号数而言存在正溢出的情况，对于正溢出，采取舍去最高位的方法。

- 二补码加法
类似的，二补码加法也存在溢出的情况，但由于二补码是符号数，这就意味着二补码不仅存在正溢出，而且还存在负溢出的情况。

$$ x+\_{w}^{t} y=\left\{\begin{array}{ll}
x+y-2^{w}, & 2^{w-1} \leqslant x+y \\
x+y, & -2^{w-1} \leqslant x+y<2^{w-1} \\
x+y+2^{w}, & x+y<-2^{w-1}
\end{array}\right. $$

### 整数的反、非
从高等代数/线性代数中线性空间的概念中我们知道如果对于加法是封闭的情况下，那么每一个数都存在其相反数(一定存在一个零元)。也即存在-a,其满足-a+a = 0，在这个条件假设下，我们称-a为整数的加法逆元。

### 整数乘法
- 无符号数乘法 
C语言中的无符号数被定义为产生w位的值，也就是用2w位的整数乘积的低w位来表示的值，我们将这个值表示为x\*y
原理：
$ x \*\_{w}^{\mathrm{u}} y=(x \cdot y) \bmod 2^{w} $ 

- 符号数乘法
C语言中的符号数乘法是用通过对2w位的乘积截断成w位来实现的，我们将这个数值表示成x\*y,将一个补码截断为w位相当于先计算该值模2^w,再把无符号数转换成补码得到。
$ x \*\_{w}^{t} y=U 2 T_{w}\left((x \cdot y) \bmod 2^{w}\right) $

> 由于整数的乘法比移位和加法的代价要大得多，许多C语言编译器试图以移位和加法减法的组合来消除很多整数乘以常数的情况。例如x\*14 = 2^3+2^2+2^1 编译器会将乘法重写成(x<<3)+(x<<2)+(x<<1)的形式。 另LEA指令能够执行形如(a<<k)+b的计算。

### 浮点数 float
> 反复读了三遍csapp和看了两遍15-213才学会的
小数点的位置是取值范围和精度的权衡-浮点的意义

1. float 的表示
![float](http://ts.githublearn.top/images/2020/07/03/float.png)
![单精度float](http://ts.githublearn.top/images/2020/07/03/float_32.png)
![双精度double](http://ts.githublearn.top/images/2020/07/03/long.png)

对于浮点数的标准化，IEEE采用$V=(-1)^{s} \times M \times 2^{E}$ 来表示浮点数
- 符号(sign) s是符号位 决定这个浮点数的正负，1为负，0为正
- 尾数(significand) M是一个二进制小数，范围时1\~2-e 
- 阶码(exponent) E的作用是对浮点数加权，权重的是2的E次幂 通过E的值来求解exp的编码

将浮点数的位表示划分为三个字段，分别对这些值进行编码。
- 一个单独的符号位s 直接编码
- k位的阶码字段$\exp =e_{k-1} \cdots e_{1} e_{0}$ 编码阶码E
- n位的小数字段编码$\text { frac }=f_{n-1} \cdots f_{1} f_{0}$ 尾数M，编码出来的值依赖阶码字段是否等于0

2. 规格化
给定位表示，根据exp的值，被编码的值可以分为三种不同的情况（最后一种情况有两个变种）
- 规格化的情况 ，这是最常见的情况，当exp的位不全为0，也不全为1 ，在这种情况下，阶码字段被解释为以偏置（bias）形式表示的有符号整数，也即阶码的值 E = exp - Bias ，（其中exp 是无符号数，$\exp =e_{k-1} \cdots e_{1} e_{0}$）
而Bias 总是等于 2^(k-1) -1的偏置值，因此对于指数的取值范围，单精度-126\~127 双精度 -1022\~1023.
> tips: 之所以采取bias 是因为我们设计的时候想让exp的值是一个有符号数，并且0处于中间。
<br>
小数字段frac 被解释为描述小数值f，其中0<=f<1,尾数定义为 M = 1+ f 。这种方式被称为隐含的以1开头的表示。可以把M看成$\text { 1. } f_{n-1} f_{n-2} \cdots f_{0}$ ,这种表述方法是一种轻松获得一个额外精度位的技巧。

- 非规格化的值 ，当exp全为0，所表示的数就是非规格化形式，在这种情况下，阶码值E=1-Bias，尾数M=f，非规格化数有两个用途
	- 提供了表示数值0的方法，因为在规格化中，我们总是使M>=1,无法表示0，实际上 +0.0的位表示为全0，s=exp=frac=0. -0.0的位表示除了s=1以外其他也均为0，值+0.0和-0.0在某些方面被认为是不同的，其他方面认为是相同的。
	- 表示那些非常接近于0的数。

- 特殊值 阶码全为1 的情况，
	- 当frac全为0时，得到的值表示无穷，当s=0 表示正无穷，s=1 表示负无穷。
	- 当frac不全为0时，结果值称为“NaN”（not a number），一些运算结果不是实数（如虚数)，就会返回NaN值。 