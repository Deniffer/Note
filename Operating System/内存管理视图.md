#### 

##### Q1:如何使用内存
Answer: 将程序放入内存中，让PC指向开始地址

##### Q2:什么时候完成重定位以及优劣
运行时?编译时?载入时? 目前的操作系统都是采用运行时重定位，编译时重定位只能放在内存的固定位置(灵活性差)，载入时重定位的程序一旦载入内存后就不能动了，（由于交换技术，所以不能采取载入时重定位）

> 重定位的概念:修改程序的地址（相对地址），将逻辑地址转换成物理地址,offset(偏移地址)+base(基地址：存放在PCB中) -> 地址翻译的过
程 

##### Q3：什么是交换(swap)
 为了解决内存空间不够大的问题引入的技术，暂时性的将进程所需要的资源放入磁盘中，等待需要的时候才换回内存，


##### Q4:什么是分段以及为什么分段
因为整个程序不是一起载入内存中的，而是以段的形式存放在内存中的
![程序员中的程序](https://cdn.jsdelivr.net/gh/Deniffer/PicBed/images/20200823094538.png)

因为不同的段的操作权限不一样（发挥不同的作用），主程序可能只需要读，变量集要有可写的权限，函数库有些可能需要载入，栈只会往下增长。采用分治的方法，将各个不同作用的部分分成一个个段，对程序的管理更加高效，符合程序员的观点，提高了内存的效率。
> mov[es:bx],bx es:段号,bx:段内偏移 采用段号+段内偏移的方式来寻址, 

![段表](https://cdn.jsdelivr.net/gh/Deniffer/PicBed/images/20200823101127.png)
每个进程PCB保存了段表(LDT表)（里面是多个段的段号）->(OS的段表是GDT表)
![GDT+LDT](https://cdn.jsdelivr.net/gh/Deniffer/PicBed/images/20200823101940.png)

![单个进程图像](https://cdn.jsdelivr.net/gh/Deniffer/PicBed/images/new_compressed.jpg)

##### Q5：如何在内存中找到一个空闲区域
可变分区与固定分区(数据结构支持:分区表,算法支持:多个分配算法)
> 操作系统通过修改分区表对内存进行管理，通过对表的更新来实现分配内存。
![可变分区的管理](https://cdn.jsdelivr.net/gh/Deniffer/PicBed/images/20200823140353.png)

算法：最佳适配法O(n)，最差适配O(n)，首先适配O(1)

##### Q6:为什么引入分页
Answer：解决内存分区导致的内存效率问题(存在内存碎片)
针对每个段内存请求，系统一页一页的分配给这个段
![页在内存的示意图](https://cdn.jsdelivr.net/gh/Deniffer/PicBed/images/20200823141909.png)
> 最大的内存浪费不会超过4K，因为一个页的大小就是4K.

cr3->寄存器，指向当前的页表
![页表结构](https://cdn.jsdelivr.net/gh/Deniffer/PicBed/images/20200823142604.png)

##### Q7:从逻辑地址到物理地址的转变
如指令 mov[0x2240],%eax 0x2240是一个逻辑地址，对应到Q6的页表结构中，Page#+Offset 的结构
1. 0x2240（16进制） 除以4K(页的大小) 等于右移12位 ，得到页号2
2. 根据页表中的页号找到物理地址所对应的页框号(这个过程页表指针和cr3来完成)cr3负责指向对应的页表，页表指针指向对应的页表的页号项 
3. 得到页框号3. 然后加上offset(240) 算得物理地址0x3240

##### Q8：页表的问题
为了提高内存空间利用率，页应该尽量的小，但是页小了，页表会相应地大了起来
$$ 2^{32}=4G/4k=1M (页表项)$$
> 1M($2^{20}$)个页表项都得放在内存中，需要4M内存(一个页表项需要4B来标识)；系统并发10个进程就需要40M的内存

![大部分逻辑地址不会用到](https://deniffer-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200823153638.png)

-trial 1: 只存放用到的页
页表中的页号不连续，需要比较、查找、这般查找$\log (2^{20})=20,每执行一条指令访问内存一次，额外访问内存20次$

-trial 2：多级页表，即页目录表（章）+页表（节）
![多级页表视图](https://deniffer-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200823155325.png)
多级页表提高了空间效率，但也增加了访存的次数 ，可以利用

- trial 3：快表   TLB(一组相联快速存储)寄存器 
![TLB工作逻辑](https://deniffer-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200823165621.png)
相联快速存储可一次比较所有项(寄存器设计复杂电路实现)达到更快速的效果，一次就能找到页号。
![TLB的有效访存时间](https://deniffer-picbed.oss-cn-shenzhen.aliyuncs.com/img/20200823170111.png)